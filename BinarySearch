Absolutely! Let’s create a **complete cheat sheet** for **all the binary search patterns** we’ve covered, with **examples, input/output, and Java code** for each. I’ll organize it by **pattern type** and make it **interview-ready**.

---

# **Binary Search Patterns – Complete Guide**

---

## **1️⃣ Basic Binary Search Patterns**

### **1.1 Search in Sorted Array**

**Problem:** Find `X` in a sorted array.

**Example:**

```java
int[] arr = {1,3,5,7,9};
int X = 5;
Output: 2 // index of 5
```

**Java Code:**

```java
public static int binarySearch(int[] arr, int x) {
    int low = 0, high = arr.length - 1;
    while(low <= high) {
        int mid = low + (high - low)/2;
        if(arr[mid] == x) return mid;
        else if(arr[mid] < x) low = mid + 1;
        else high = mid - 1;
    }
    return -1; // not found
}
```

---

### **1.2 Lower Bound**

* Finds **first index ≥ X**

```java
int[] arr = {1,3,3,5,7}, x = 3
Output: 1
```

```java
public static int lowerBound(int[] arr, int x) {
    int low=0, high=arr.length-1, ans=arr.length;
    while(low <= high){
        int mid = low + (high-low)/2;
        if(arr[mid] >= x){
            ans = mid;
            high = mid-1;
        } else low = mid+1;
    }
    return ans;
}
```

---

### **1.3 Upper Bound**

* Finds **first index > X**

```java
int[] arr = {1,3,3,5,7}, x = 3
Output: 3
```

```java
public static int upperBound(int[] arr, int x){
    int low=0, high=arr.length-1, ans=arr.length;
    while(low <= high){
        int mid = low + (high-low)/2;
        if(arr[mid] > x){
            ans = mid;
            high = mid-1;
        } else low = mid+1;
    }
    return ans;
}
```

---

## **2️⃣ Rotated Array Search**

### **2.1 Search in Rotated Sorted Array**

```java
int[] arr = {4,5,6,7,0,1,2};
int X = 0;
Output: 4
```

```java
public static int searchRotated(int[] arr, int x) {
    int low=0, high=arr.length-1;
    while(low <= high){
        int mid = low + (high-low)/2;
        if(arr[mid] == x) return mid;
        if(arr[low] <= arr[mid]){
            if(x >= arr[low] && x < arr[mid]) high = mid-1;
            else low = mid+1;
        } else {
            if(x > arr[mid] && x <= arr[high]) low = mid+1;
            else high = mid-1;
        }
    }
    return -1;
}
```

---

### **2.2 Find Minimum in Rotated Sorted Array**

```java
int[] arr = {4,5,6,7,0,1,2};
Output: 0
```

```java
public static int findMin(int[] arr){
    int low=0, high=arr.length-1;
    while(low < high){
        int mid = low + (high-low)/2;
        if(arr[mid] > arr[high]) low = mid+1;
        else high = mid;
    }
    return arr[low];
}
```

---

## **3️⃣ Binary Search on Answer**

### **3.1 Smallest Divisor**

```java
int[] nums = {1,2,5,9}, threshold = 6
Output: 5
```

```java
class Solution {
    public int smallestDivisor(int[] nums, int threshold) {
        int low = 1, high = Arrays.stream(nums).max().getAsInt();
        int ans = high;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(isValid(nums, mid, threshold)){
                ans = mid;
                high = mid-1;
            } else low = mid+1;
        }
        return ans;
    }
    private boolean isValid(int[] nums, int divisor, int threshold){
        int sum=0;
        for(int num: nums){
            sum += (num+divisor-1)/divisor;
            if(sum > threshold) return false;
        }
        return true;
    }
}
```

---

### **3.2 Koko Eating Bananas**

```java
int[] piles = {3,6,7,11}, H=8
Output: 4
```

```java
class Solution {
    public int minEatingSpeed(int[] piles, int H){
        int low=1, high=Arrays.stream(piles).max().getAsInt();
        int ans = high;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(canEat(piles, mid, H)){
                ans = mid;
                high = mid-1;
            } else low = mid+1;
        }
        return ans;
    }
    private boolean canEat(int[] piles, int speed, int H){
        int hours = 0;
        for(int p : piles) hours += (p+speed-1)/speed;
        return hours <= H;
    }
}
```

---

### **3.3 Minimum Days to Make M Bouquets**

```java
int[] bloomDay = {1,10,3,10,2}, m=3, k=1
Output: 3
```

```java
class Solution {
    public int minDays(int[] bloomDay, int m, int k){
        if((long)m*k > bloomDay.length) return -1;
        int low = Arrays.stream(bloomDay).min().getAsInt();
        int high = Arrays.stream(bloomDay).max().getAsInt();
        int ans = -1;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(valid(bloomDay, m, k, mid)){
                ans = mid;
                high = mid-1;
            } else low = mid+1;
        }
        return ans;
    }
    private boolean valid(int[] bloomDay, int m, int k, int day){
        int cnt=0;
        for(int d: bloomDay){
            if(d <= day){
                cnt++;
                if(cnt==k){
                    m--;
                    cnt=0;
                }
            } else cnt=0;
        }
        return m<=0;
    }
}
```

---

### **3.4 Aggressive Cows**

```java
int[] stalls = {1,2,4,8,9}, k=3
Output: 3
```

```java
class Solution {
    public static boolean canPlace(int[] stalls, int k, int dist){
        int cows = 1, last = stalls[0];
        for(int i=1;i<stalls.length;i++){
            if(stalls[i]-last >= dist){
                cows++;
                last = stalls[i];
            }
            if(cows==k) return true;
        }
        return false;
    }
    public static int aggressiveCows(int[] stalls, int k){
        Arrays.sort(stalls);
        int low=0, high=stalls[stalls.length-1]-stalls[0], ans=0;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(canPlace(stalls, k, mid)){
                ans = mid;
                low = mid+1;
            } else high = mid-1;
        }
        return ans;
    }
}
```

---

### **3.5 Book Allocation**

```java
int[] pages = {12,34,67,90}, m=2
Output: 113
```

```java
class Solution {
    public boolean canAllocate(int[] pages, int m, int maxPages){
        int students = 1, sum=0;
        for(int p: pages){
            if(sum + p > maxPages){
                students++;
                sum = p;
                if(students>m) return false;
            } else sum+=p;
        }
        return true;
    }
    public int bookAllocation(int[] pages, int m){
        if(m > pages.length) return -1;
        int low=Arrays.stream(pages).max().getAsInt();
        int high = Arrays.stream(pages).sum();
        int ans=-1;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(canAllocate(pages, m, mid)){
                ans = mid;
                high = mid-1;
            } else low=mid+1;
        }
        return ans;
    }
}
```

---

### **3.6 Split Array – Largest Sum**

```java
int[] nums = {7,2,5,10,8}, k=2
Output: 18
```

```java
class Solution {
    public boolean canSplit(int[] nums, int k, int maxSum){
        int parts=1, curr=0;
        for(int n: nums){
            if(curr+n > maxSum){
                parts++;
                curr=n;
                if(parts>k) return false;
            } else curr+=n;
        }
        return true;
    }
    public int splitArray(int[] nums, int k){
        int low = Arrays.stream(nums).max().getAsInt();
        int high = Arrays.stream(nums).sum();
        int ans=-1;
        while(low <= high){
            int mid = low + (high-low)/2;
            if(canSplit(nums, k, mid)){
                ans = mid;
                high = mid-1;
            } else low = mid+1;
        }
        return ans;
    }
}
```

---

### **3.7 Minimize Max Distance to Gas Station**

```java
int[] stations = {1,2,3,4,5}, K=4
Output: 0.5
```

```java
class Solution {
    public boolean canPlace(int[] stations, int K, double dist){
        int required = 0;
        for(int i=1;i<stations.length;i++)
            required += (int)((stations[i]-stations[i-1])/dist);
        return required <= K;
    }
    public double minmaxGasDist(int[] stations, int K){
        double low=0.0, high=0.0;
        for(int i=1;i<stations.length;i++)
            high = Math.max(high, stations[i]-stations[i-1]);
        while(high - low > 1e-6){
            double mid = (low+high)/2;
            if(canPlace(stations, K, mid)) high = mid;
            else low = mid;
        }
        return high;
    }
}
```

---

